import { SlideLayout, Image, FlexBox, Box } from 'spectacle'
import { CodeDisplay, File, Tests } from '../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## Understanding Functions: The Building Blocks

Functions are reusable blocks of code that:

**1. Encapsulate Logic**
- Group related operations together
- Create reusable code that can be called multiple times
- Accept inputs (parameters) and return outputs

**2. Promote Organization**
- Break complex problems into smaller pieces
- Make code easier to read and maintain
- Enable testing of individual components

**3. Enable Abstraction**
- Hide implementation details
- Provide clean interfaces for complex operations
- Allow code reuse across different parts of your application
</SlideLayout.Full>

<SlideLayout.Full>
## Function Fundamentals

**Function Declaration:**
```javascript
function calculatePoints(streak) {
  return streak * 10;
}
```

**Function Expression:**
```javascript
const calculatePoints = function(streak) {
  return streak * 10;
};
```

**Arrow Function:**
```javascript
const calculatePoints = (streak) => streak * 10;
```

**Key Concepts:**
- Parameters vs Arguments
- Return values vs side effects
- Scope and variable access
- Function naming best practices
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise Overview: Habit Function Library

You'll build a set of utility functions for habit tracking:

1. **calculateStreak()** - Count completion days
2. **isHabitCompleted()** - Check if habit was done on a date
3. **getPoints()** - Calculate points based on streak

**Function Design Principles:**
- Each function should do one thing well
- Use descriptive names that explain what the function does
- Accept the minimum data needed to complete the task
- Return a useful value for the caller

**Progressive Enhancement**: Start simple, then add modern syntax
</SlideLayout.Full>

<SlideLayout.Full>
## Functions: The Heart of JavaScript

<CodeDisplay >
  <File name="habitFunctions.js">
    
```javascript
// Exercise: Create functions for habit tracking
// TODO: Create three functions:
// 1. calculateStreak - takes array of dates, returns count
// 2. isHabitCompleted - takes habit and date, returns boolean
// 3. getPoints - takes streak number, returns points (streak * 10)

// Your code here...

// Test your functions
console.log(calculateStreak(['2024-01-01', '2024-01-02']));
console.log(isHabitCompleted({ completions: ['2024-01-01'] }, '2024-01-01'));
console.log(getPoints(5));
```
    
    
```javascript
// Step 1: Basic function declaration
function calculateStreak(completionDates) {
  return completionDates.length;
}

function isHabitCompleted(habit, date) {
  // Check if date exists in completions array
  for (let i = 0; i < habit.completions.length; i++) {
    if (habit.completions[i] === date) {
      return true;
    }
  }
  return false;
}

function getPoints(streak) {
  return streak * 10;
}

// Test them
console.log(calculateStreak(['2024-01-01', '2024-01-02'])); // 2
console.log(isHabitCompleted({ completions: ['2024-01-01'] }, '2024-01-01')); // true
console.log(getPoints(5)); // 50
```
    
    
```javascript
// Step 2: Refactor with modern syntax
// Function declaration - still good for main functions
function calculateStreak(completionDates) {
  return completionDates.length;
}

// Function expression - useful for conditional assignment
const isHabitCompleted = function(habit, date) {
  // Modern array method
  return habit.completions.includes(date);
};

// Arrow function - concise for simple operations
const getPoints = (streak) => streak * 10;

// Arrow function with block body for complex logic
const getStreakBonus = (streak) => {
  if (streak >= 30) return 100;
  if (streak >= 7) return 25;
  return 0;
};

// Test them
console.log(calculateStreak(['2024-01-01', '2024-01-02'])); // 2
console.log(getPoints(5)); // 50
console.log(getStreakBonus(30)); // 100
```
    
  </File>
  <Tests>
    
```javascript
// Test: Functions should work correctly
describe('Habit Functions', () => {
  it('should calculate streak from dates array', () => {
    expect(calculateStreak(['2024-01-01', '2024-01-02'])).to.equal(2);
    expect(calculateStreak([])).to.equal(0);
  });
  
  it('should check if habit was completed on date', () => {
    const habit = { completions: ['2024-01-01', '2024-01-03'] };
    expect(isHabitCompleted(habit, '2024-01-01')).to.equal(true);
    expect(isHabitCompleted(habit, '2024-01-02')).to.equal(false);
  });
  
  it('should calculate points based on streak', () => {
    expect(getPoints(0)).to.equal(0);
    expect(getPoints(5)).to.equal(50);
    expect(getPoints(10)).to.equal(100);
  });

  it('should implement all required functions', () => {
    expect(typeof calculateStreak).to.equal('function');
    expect(typeof isHabitCompleted).to.equal('function');
    expect(typeof getPoints).to.equal('function');
    
    expect(calculateStreak(['a', 'b', 'c'])).to.equal(3);
    expect(getPoints(7)).to.equal(70);
  });

  it('should use includes for array checking', () => {
    const habit = { completions: ['2024-01-01', '2024-01-03'] };
    expect(isHabitCompleted(habit, '2024-01-01')).to.equal(true);
    expect(isHabitCompleted(habit, '2024-01-02')).to.equal(false);
  });
  
  it('should calculate streak bonuses', () => {
    if (typeof getStreakBonus === 'function') {
      expect(getStreakBonus(2)).to.equal(0);
      expect(getStreakBonus(7)).to.equal(25);
      expect(getStreakBonus(30)).to.equal(100);
      expect(getStreakBonus(100)).to.equal(100);
    }
  });
});
```
    
  </Tests>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Functions as First-Class Citizens

<CodeDisplay >
  <File name="advancedFunctions.js">
```javascript
// Step 3: Functions as first-class citizens
// Store functions in variables
const scoreCalculator = getPoints;
const bonusCalculator = getStreakBonus;

// Pass functions as arguments
function calculateTotalScore(streak, pointsFn, bonusFn) {
  return pointsFn(streak) + bonusFn(streak);
}

// Return functions from functions
function createMultiplier(factor) {
  return (value) => value * factor;
}

const doublePoints = createMultiplier(2);
const triplePoints = createMultiplier(3);

// Use them
console.log(scoreCalculator(5)); // 50
console.log(calculateTotalScore(30, getPoints, getStreakBonus)); // 300 + 100 = 400
console.log(doublePoints(10)); // 20
console.log(triplePoints(10)); // 30
```
</File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Function Parameters and Logic

Before building the analytics function, understand these patterns:

**Switch Statements in Functions:**
```javascript
function getGrade(score) {
  switch (true) {
    case score >= 90: return "A";
    case score >= 80: return "B"; 
    case score >= 70: return "C";
    default: return "F";
  }
}
```

**Calculation Functions:**
```javascript
function calculatePercentage(completed, total) {
  if (total === 0) return 0;
  return Math.round((completed / total) * 100);
}
```

**The Goal**: Build a versatile analytics function that can perform different calculations based on the action parameter.
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Function Calculator
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Habit Tracker: Create a habit analytics function
// Exercise: Build a function that analyzes habit completion data

function analyzeHabit(action, habitData) {
  // Your code here
  // Actions: "streak", "points", "completion-rate", "best-day"
}

// Test data
const myHabit = {
  name: "Morning Exercise",
  completions: ['2024-01-01', '2024-01-02', '2024-01-04', '2024-01-05', '2024-01-06'],
  totalDays: 7,
  pointsPerDay: 10
};

console.log(analyzeHabit("streak", myHabit));
console.log(analyzeHabit("points", myHabit));
console.log(analyzeHabit("completion-rate", myHabit));
```
    
    
```javascript
// Solution: Comprehensive analytics function
function analyzeHabit(action, habitData) {
  switch (action) {
    case "streak":
      return habitData.completions.length;
    
    case "points":
      return habitData.completions.length * habitData.pointsPerDay;
    
    case "completion-rate":
      const rate = (habitData.completions.length / habitData.totalDays) * 100;
      return Math.round(rate);
    
    case "best-day":
      if (habitData.completions.length === 0) return "No completions yet";
      // Find the most recent completion
      const sorted = habitData.completions.sort();
      return sorted[sorted.length - 1];
    
    default:
      return "Unknown action";
  }
}

// Test data
const myHabit = {
  name: "Morning Exercise",
  completions: ['2024-01-01', '2024-01-02', '2024-01-04', '2024-01-05', '2024-01-06'],
  totalDays: 7,
  pointsPerDay: 10
};

console.log("Current streak:", analyzeHabit("streak", myHabit));      // 5
console.log("Total points:", analyzeHabit("points", myHabit));        // 50
console.log("Completion rate:", analyzeHabit("completion-rate", myHabit) + "%"); // 71%
console.log("Most recent completion:", analyzeHabit("best-day", myHabit)); // 2024-01-06
```
    
  </File>
  <Tests>
    
```javascript
// Tests for Function Calculator
describe('Habit Analytics Function', () => {
  it('should calculate streak correctly', () => {
    expect(analyzeHabit("streak", myHabit)).to.equal(5);
  });
  
  it('should calculate points correctly', () => {
    expect(analyzeHabit("points", myHabit)).to.equal(50);
  });
  
  it('should calculate completion rate correctly', () => {
    expect(analyzeHabit("completion-rate", myHabit)).to.equal(71);
  });
  
  it('should find best day correctly', () => {
    expect(analyzeHabit("best-day", myHabit)).to.equal('2024-01-06');
  });
  
  it('should handle unknown actions', () => {
    expect(analyzeHabit("unknown", myHabit)).to.equal("Unknown action");
  });
});
```
    
  </Tests>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## Common Function Pitfalls

**Avoid these common mistakes:**

1. **Arrow Function `this` Binding**
```javascript
const habitTracker = {
  count: 0,
  increment: () => {
    this.count++; // âŒ Arrow functions don't have their own 'this'
  }
};
```

2. **Forgetting Return in Arrow Functions**
```javascript
// This returns undefined!
const getPoints = (streak) => {
  streak * 10; // Missing return
};

// Correct:
const getPoints = (streak) => streak * 10;
// OR
const getPoints = (streak) => {
  return streak * 10;
};
```

3. **Function Hoisting Confusion**
```javascript
console.log(declaredFn()); // âœ… Works - hoisted
console.log(expressionFn()); // âŒ Error - not hoisted

function declaredFn() { return "I'm hoisted!"; }
const expressionFn = () => "I'm not hoisted!";
```
</SlideLayout.Full>

<SlideLayout.Full>
## Debugging Functions

**Pro tips for debugging functions:**

1. **Use console.log() strategically**
```javascript
function calculateHabitScore(habit) {
  console.log('Input habit:', habit); // Check input
  
  const baseScore = habit.streak * 10;
  console.log('Base score:', baseScore); // Check calculation
  
  const bonus = habit.difficulty === 'hard' ? 50 : 0;
  console.log('Bonus:', bonus); // Check logic
  
  return baseScore + bonus;
}
```

2. **Use debugger statement**
```javascript
function complexCalculation(data) {
  debugger; // Pauses execution in DevTools
  // Step through code line by line
}
```

3. **Check function.name for debugging**
```javascript
const myFunc = () => console.log('Running:', myFunc.name);
```
</SlideLayout.Full>

<SlideLayout.Full>
## ðŸŽ¯ Key Takeaways: Functions

1. **Functions reduce repetition** and make code reusable
2. **Three ways to create**: declaration, expression, arrow
3. **Hoisting** only works with function declarations
4. **First-class citizens**: can be passed around like values
5. **Pure functions** are easier to test and debug

### Bridge to Control Flow
Functions organize code into reusable blocks. Next, let's learn how to make those blocks **smart** with conditional logic and loops!
</SlideLayout.Full>